my text = [
    "This is random text",
    "that will be boxed with this function.",
    "I have set it to be 3"
];

boxify(text, 4);

func boxify(strings_to_box, w_on_sides) {

    my index = 0;
    my longest_str_len = 0;

    for(strings_to_box) -> string {
        my str_len = string.chars();
        if(str_len > longest_str_len) {
            longest_str_len = str_len;
        }
    }

    my box_w = longest_str_len + w_on_sides;

    say(generate_top(box_w));

    for(strings_to_box) -> print_ln {
        my ln = "║";

        ln = ln ~generate_w_space_before(w_on_sides);
        ln = ln ~print_ln;
        ln = ln ~generate_w_space_after(w_on_sides,print_ln.chars(),longest_str_len);
        ln = ln ~"║";
        say(ln);
    }

    say(generate_bottom(box_w));

}

func generate_top(w) {
    my top = "╔";
    my line = "";
    my counter = 0;
    while (counter < (w+2)) {
        line = line ~ "═";
        counter = counter + 1;
    }
    my top_line = ~top ~line ~"╗";
    return top_line;
}

func generate_bottom(w) {
    my top = "╚";
    my line = "";
    my counter = 0;
    while (counter < (w+2)) {
        line = line ~ "═";
        counter = counter + 1;
    }
    my top_line = ~top ~line ~"╝";
    return top_line;
}

func generate_w_space_before(w) {
    my spaces = w-1;
    my spaces_ln = "";
    for(^spaces) {
        spaces_ln = spaces_ln ~" ";
    }
    return spaces_ln;
}

func generate_w_space_after(w,this,max) {

    my spaces = max - this + (w-1);

    my spaces_ln = "";
    for(^spaces) {
        spaces_ln = spaces_ln ~" ";
    }
    return spaces_ln;
}



